# Autogenerated from a Treetop grammar. Edits may be lost.


module Musicality
module Parsing

module Pitch
  include Treetop::Runtime

  def root
    @root ||= :pitch
  end

  include NonnegativeInteger

  module Pitch0
    def pitch_letter
      elements[0]
    end

    def mod
      elements[1]
    end

    def octave
      elements[2]
    end

    def cents
      elements[3]
    end
  end

  def _nt_pitch
    start_index = index
    if node_cache[:pitch].has_key?(index)
      cached = node_cache[:pitch][index]
      if cached
        node_cache[:pitch][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_pitch_letter
    s0 << r1
    if r1
      if has_terminal?(@regexps[gr = '\A[#b]'] ||= Regexp.new(gr), :regexp, index)
        r3 = true
        @index += 1
      else
        terminal_parse_failure('[#b]')
        r3 = nil
      end
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
      if r2
        r4 = _nt_octave
        s0 << r4
        if r4
          r6 = _nt_cent
          if r6
            r5 = r6
          else
            r5 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r5
        end
      end
    end
    if s0.last
      r0 = instantiate_node(PitchNode,input, i0...index, s0)
      r0.extend(Pitch0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:pitch][start_index] = r0

    r0
  end

  module Octave0
    def n
      elements[0]
    end
  end

  module Octave1
    def to_i; n.to_i; end
  end

  def _nt_octave
    start_index = index
    if node_cache[:octave].has_key?(index)
      cached = node_cache[:octave][index]
      if cached
        node_cache[:octave][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_nonnegative_integer
    s0 << r1
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Octave0)
      r0.extend(Octave1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:octave][start_index] = r0

    r0
  end

  module Cent0
    def n
      elements[1]
    end
  end

  module Cent1
    def to_i; text_value.to_i; end
  end

  def _nt_cent
    start_index = index
    if node_cache[:cent].has_key?(index)
      cached = node_cache[:cent][index]
      if cached
        node_cache[:cent][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?(@regexps[gr = '\A[+-]'] ||= Regexp.new(gr), :regexp, index)
      r1 = true
      @index += 1
    else
      terminal_parse_failure('[+-]')
      r1 = nil
    end
    s0 << r1
    if r1
      r2 = _nt_nonnegative_integer
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Cent0)
      r0.extend(Cent1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:cent][start_index] = r0

    r0
  end

  def _nt_pitch_letter
    start_index = index
    if node_cache[:pitch_letter].has_key?(index)
      cached = node_cache[:pitch_letter][index]
      if cached
        node_cache[:pitch_letter][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_letter_a
    if r1
      r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
      r0 = r1
    else
      r2 = _nt_letter_b
      if r2
        r2 = SyntaxNode.new(input, (index-1)...index) if r2 == true
        r0 = r2
      else
        r3 = _nt_letter_c
        if r3
          r3 = SyntaxNode.new(input, (index-1)...index) if r3 == true
          r0 = r3
        else
          r4 = _nt_letter_d
          if r4
            r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
            r0 = r4
          else
            r5 = _nt_letter_e
            if r5
              r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
              r0 = r5
            else
              r6 = _nt_letter_f
              if r6
                r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                r0 = r6
              else
                r7 = _nt_letter_g
                if r7
                  r7 = SyntaxNode.new(input, (index-1)...index) if r7 == true
                  r0 = r7
                else
                  @index = i0
                  r0 = nil
                end
              end
            end
          end
        end
      end
    end

    node_cache[:pitch_letter][start_index] = r0

    r0
  end

  module LetterA0
    def to_semitone; 9; end
  end

  def _nt_letter_a
    start_index = index
    if node_cache[:letter_a].has_key?(index)
      cached = node_cache[:letter_a][index]
      if cached
        node_cache[:letter_a][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?(@regexps[gr = '\A[Aa]'] ||= Regexp.new(gr), :regexp, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      r0.extend(LetterA0)
      @index += 1
    else
      terminal_parse_failure('[Aa]')
      r0 = nil
    end

    node_cache[:letter_a][start_index] = r0

    r0
  end

  module LetterB0
    def to_semitone; 11; end
  end

  def _nt_letter_b
    start_index = index
    if node_cache[:letter_b].has_key?(index)
      cached = node_cache[:letter_b][index]
      if cached
        node_cache[:letter_b][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?(@regexps[gr = '\A[Bb]'] ||= Regexp.new(gr), :regexp, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      r0.extend(LetterB0)
      @index += 1
    else
      terminal_parse_failure('[Bb]')
      r0 = nil
    end

    node_cache[:letter_b][start_index] = r0

    r0
  end

  module LetterC0
    def to_semitone; 0; end
  end

  def _nt_letter_c
    start_index = index
    if node_cache[:letter_c].has_key?(index)
      cached = node_cache[:letter_c][index]
      if cached
        node_cache[:letter_c][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?(@regexps[gr = '\A[Cc]'] ||= Regexp.new(gr), :regexp, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      r0.extend(LetterC0)
      @index += 1
    else
      terminal_parse_failure('[Cc]')
      r0 = nil
    end

    node_cache[:letter_c][start_index] = r0

    r0
  end

  module LetterD0
    def to_semitone; 2; end
  end

  def _nt_letter_d
    start_index = index
    if node_cache[:letter_d].has_key?(index)
      cached = node_cache[:letter_d][index]
      if cached
        node_cache[:letter_d][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?(@regexps[gr = '\A[Dd]'] ||= Regexp.new(gr), :regexp, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      r0.extend(LetterD0)
      @index += 1
    else
      terminal_parse_failure('[Dd]')
      r0 = nil
    end

    node_cache[:letter_d][start_index] = r0

    r0
  end

  module LetterE0
    def to_semitone; 4; end
  end

  def _nt_letter_e
    start_index = index
    if node_cache[:letter_e].has_key?(index)
      cached = node_cache[:letter_e][index]
      if cached
        node_cache[:letter_e][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?(@regexps[gr = '\A[Ee]'] ||= Regexp.new(gr), :regexp, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      r0.extend(LetterE0)
      @index += 1
    else
      terminal_parse_failure('[Ee]')
      r0 = nil
    end

    node_cache[:letter_e][start_index] = r0

    r0
  end

  module LetterF0
    def to_semitone; 5; end
  end

  def _nt_letter_f
    start_index = index
    if node_cache[:letter_f].has_key?(index)
      cached = node_cache[:letter_f][index]
      if cached
        node_cache[:letter_f][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?(@regexps[gr = '\A[Ff]'] ||= Regexp.new(gr), :regexp, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      r0.extend(LetterF0)
      @index += 1
    else
      terminal_parse_failure('[Ff]')
      r0 = nil
    end

    node_cache[:letter_f][start_index] = r0

    r0
  end

  module LetterG0
    def to_semitone; 7; end
  end

  def _nt_letter_g
    start_index = index
    if node_cache[:letter_g].has_key?(index)
      cached = node_cache[:letter_g][index]
      if cached
        node_cache[:letter_g][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?(@regexps[gr = '\A[Gg]'] ||= Regexp.new(gr), :regexp, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      r0.extend(LetterG0)
      @index += 1
    else
      terminal_parse_failure('[Gg]')
      r0 = nil
    end

    node_cache[:letter_g][start_index] = r0

    r0
  end

end

class PitchParser < Treetop::Runtime::CompiledParser
  include Pitch
end


end
end